# トランザクションについて

## ACID 特性

### A

Atomicity (原子性)

トランザクションは、完全に完了する or もとに戻す のどちらかでなくていはいけない

`write A`と`write B`の 2 つの処理が`Transaction X`だとすると`write A`だけもしくは`write B`だけが完了していてはいけない。

残りも完全に完了するか、ロールバックして操作をもとに戻す必要がある。

### C

Consistency (整合性、一貫性)

_コレはいまいちよく分かっていない_

予め与えられた整合性をトランザクションの前後で保たなくてはいけない。

例えば、銀行口座の残高は負になってはいけない、負になる場合は送金できないようにする。などのルールを保証するのが一貫性である。

### I

Isolation (独立性)

トランザクション A で変更しているデータをトランザクション B では処理できない。

トランザクションが直列化されている必要がある。(おそらく直列化して処理すると速度に問題があるので、厳密には直列ではないはず。だがそう見えるようにはなっているはず)

### D

Durability (永続性)

一旦コミットしたら、結果は失われてはいけない

## 排他制御 (同時実行制御)

排他制御には 2 つの制御方法がある。

- ペシミスティック同時制御 (悲観的同時制御)
- オプティミスティック同時制御 (楽観的同時制御)

### ペシミスティック同時制御

これは不整合をあらかじめ防ぐような同時実行制御の方法。

あるトランザクションが特定のデータを更新するためにその値を読むとき、そのデータはロックされ、他のトランザクションでは値の更新が完了してロックが解除されるまで値の読み取りができない。

このように、あるトランザクションでのデータ変更が、他のトランザクションに影響することを**あらかじめ**防ぐ

### オプティミスティック同時制御

不整合が発生したときに不整合を解消すればいいという考えのもと制御する方法。

2 つのトランザクション A,B があったとして、トランザクション A はトランザクション B が更新中でもデータを読み取ることが出来る。
しかし、トランザクション A がデータを更新するとき B がすでにそのデータを書き換えていた場合、処理内容を abort して最初から処理を再開する。

トランザクションの処理中に他のトランザクションによって対象のデータが書き換えられたかどうかは、データベース管理システムが確認している。

もし、すでにデータが更新されていたなら、トランザクションはアボートされ、更新結果を反映した上で、トランザクション処理をやり直す。

### 2 相ロック

リレーション A とリレーション B を更新するトランザクション X があったとする。

トランザクション X はリレーション A を更新する際排他ロックをかける。そして、そのデータの更新を行い、アンロックする。
次にリレーション B での同様の手順で更新を行う。

この場合、複数トランザクションの並列処理が行われた場合、不整合が起こる可能性がある。

そのため、処理対象であるデータに対して、ロック相とアンロック相の 2 つのフェーズに分けることでトランザクションの並列処理を行う。

更新し終わったデータのロックは順次開放するのではなく、アンロック相(アンロックフェーズ)に入ってから開放し始める。

## トランザクションの分離レベル

そもそもなぜ、分離レベルが必要になるのか? 分離レベルとは何なのか？

直列化可能なスケジュールでトランザクションを処理し、データの整合性を保証することは出来る。しかし、それではトランザクションの処理効率を下げてしまう。

なので、トランザクションを高速に処理したい場合にある程度の不整合を許容する必要がある。
この不整合を段階的に定めたものがトランザクションの分離レベル。

| 分離レベル       | ダーティーリード | ファジーリード | ファントムリード |
| ---------------- | ---------------- | -------------- | ---------------- |
| SERIALIZABLE     | x                | x              | x                |
| REPEATABLE READ  | x                | x              | o                |
| READ COMMITTED   | x                | o              | o                |
| READ UNCOMMITTED | o                | o              | o                |

まず、それぞれの分離レベルについて書いていく

### SERIALIZABLE

直列可能であることを示す。一番厳密なトランザクションの分離レベル。

## REPEATABLE READ

同じデータを何度読み取っても同じ内容であることを保証する。

ただし、広範囲のロックは使用されないため、他のトランザクションによる、データの追加、削除は許可される。

ここからファントムリードが発生しだす。

## READ COMMITTED

トランザクション A の処理中に、トランザクション B が commit したデータを読み取ることを許可する分離レベル。

ここからファジーリードが発生しだす。

## READ UNCOMMITTED

他のトランザクションが確定していないデータまで読み取ることを許可する分離レベル。

ダーティーリードが発生しだす。

次に、それぞれの不整合について書いていく

### ファントムリード

トランザクション A が処理を行う途中で、トランザクション B がによって DB に追加 or 削除されたデータを、その前後で読み取ってしまう。

### ファジーリード

ノンリピータブルリードとも言うらしい。(こっちのほうが分かりやすい名前なきがする)

トランザクション A が処理を行う途中で、トランザクション B によって更新されたデータを読み込んでしまう現象である。

### ダーティーリード

まだコミットされていない他のトランザクションのデータを読み込んでしまう。

他のトランザクションのデータが abort された場合であっても、それを反映できない。
